
AVRASM ver. 1.56  C:\Users\thevbess\Desktop\Morse-MT-master\ad2.asm Tue May 27 22:57:34 2014


         ; =============================================== ;
         ; file: ad2.asm
         ; Intro : Main implementation file for microcontrollers projet
         ; Contains : main routines for morse decoder
         ; Authors : Group M3 ( Dylan Bourgeois & Tristan Besson)
         ; Last modified : 27.05.2014 @ 14:16
         ; =============================================== ;
         
          .include "m103def.inc"		; include AVR port/bit definitions
          .nolist
          .include "definitions.asm"	; include register/constant definitions
         ; file:	definitions.asm
         ; copyright (c) 2000-2002 R.Holzer
         ; 2002-01-09
         ; 20130628 A.Schmid CA01
         
         ; === definitions  ===
          .nolist			; do not include in listing
         
         ; DEFINE : PORTS
          .equ 	MORSE_PORT = 2		; define analog port to be used
         
         ; DEFINE : LEVELS
          .equ	LEVEL_NB_PICS = 0x40	; define level for number of pics (64)
          .equ	LEVEL_SND = 63		; define sound strength level
         
         ; DEFINE : PRESCALERS
          .equ	AD_PS = 5		; define AD prescaler = 5 (f=125kHz)
          .equ	TIMER_PS = 2		; define timer prescaler = 2 (T=131ms)
         
         ; DEFINE : ARITHMETIC CONSTANTS
          .equ	SIGNED = 127		; define constant to bring back counter to signed
         
         ; DEFINE : SYMBOLS
          .equ	SHORT_SYMB = 0b01	; define buffer symbolic for short signal
          .equ	LONG_SYMB = 0b10	; define buffer symbolic for long signal
         
         ;============== Interrupt Vector Table ===============
          .org	0 
000000 c041      	rjmp	reset  
          .org	OVF1addr
00001c c019      	rjmp	analyse
          .org	0x30
         
          short:
          .db	"short",0
000030 6873
000031 726f
000032 0074
         
          long:
          .db	"long ",0
000033 6f6c
000034 676e
000035 0020
         
         ;============== Interrupt Service Routine ============	
          analyse:
000036 e410      	ldi	_w,LEVEL_NB_PICS ; _w=64 (nb de pics)
000037 1a81      	sub	c0,_w	; compare nb of pics / seuil
000038 f020      	brlo	PC+5	; if nb de pics > seuil, inc counter
000039 2499      	clr	c1
00003a 94e3      	inc	d2	
00003b 2488      	clr	c0	; clear pic counter
00003c 9518      	reti		; and leave
00003d 9493      	inc	c1		
00003e d1b9      	rcall	shortlong ; else sound is over, call routine to see if s or l
00003f 24ee      	clr	d2	; clear after compare
000040 2488      	clr	c0	; clear pic counter
000041 9518      	reti		; return for interrupt
         	
         ;============== Initialisation Reset =================
          reset:
000042   +  	LDSP	RAMEND		; set up stack pointer (SP)
         	
000046   +  	OUTI	DDRB,0xff	; set LEDs as output in debug mode
         	
000048   +  	OUTI	ASSR,(1<<AS0)	; enable AD type 0
00004a   +  	OUTI	ADCSR,(1<<ADEN)+AD_PS ; AD Enable, PS=CK/2^5=CK/32	
00004c   +  	OUTI	ADMUX,MORSE_PORT; select channel MORSE_PORT
         	
00004e   +  	OUTI	TIMSK,(1<<TOIE1) ; Enable quartz timer (timer1)
000050   +  	OUTI 	TCCR1B,TIMER_PS	; PS=CK/4, overflow period : 131 ms
000052 9478      	sei
         	
000053 d002      	rcall	clr_init
000054 d039      	rcall	LCD_init	; initialize the LCD
         	
000055 c17f      	rjmp	main		; jump ahead to the main program
         
         ;============= Init routines ========================
         ; init counter : clear ALL the counters !	
          clr_init:
000056 2766      	clr	b0		; sound level value
000057 2777      	clr	b1		; seuil value
000058 2799      	clr	b3		; character counter
000059 2488      	clr	c0		; compteur de pics
00005a 2499      	clr	c1		; void counter
00005b 24aa      	clr	c2		; did counter start on same pulse
00005c 24bb      	clr	c3		; should restart timer 
00005d 24cc      	clr	d0		; ACDH
00005e 24dd      	clr	d1		; ACDL
00005f 24ee      	clr	d2		; count pulses
000060 24ff      	clr	d3		; buffer
000061 9508      	ret	
         
         ; clear timer counter register	
          clr_timer:
         	;OUTI	TCNT1H,0
         	;OUTI	TCNT1L,0
         	;OUTI	TCNT0,0
000062 9508      	ret
         
         ;============= External ==========================
          .include "lcd.asm"		; include the LCD routines
         ; file	lcd.asm
         ; copyright (c) 2000-2002 R.Holzer
         ; 2002-01-19
         
         ; === definitions ===
          .equ	LCD_IR	= 0x8000	; address LCD instruction reg
          .equ	LCD_DR	= 0xc000	; address LCD data register
         
         ; === subroutines ===
          LCD_wr_ir:
         ; in	w (byte to write to LCD IR)
000063 9030 8000 	lds	u, LCD_IR	; read IR to check busy flag  (bit7)
000065   +  	JB1	u,7,LCD_wr_ir	; Jump if Bit=1 (still busy)
000067 d003      	rcall	lcd_4us		; delay to increment DRAM addr counter
000068 9300 8000 	sts	LCD_IR, w	; store w in IR
00006a 9508      	ret
         	
          lcd_4us:
00006b d000      	rcall	lcd_2us		; recursive call		
          lcd_2us:
00006c 0000      	nop			; rcall(3) + nop(1) + ret(4) = 8 cycles (2us)
00006d 9508      	ret
         
          LCD:
          LCD_putc:
00006e   +  	JK	a0,CR,LCD_cr	; Jump if a0=CR
000070   +  	JK	a0,LF,LCD_lf	; Jump if a0=LF
          LCD_wr_dr:
         ; in	a0 (byte to write to LCD DR)
000072 9100 8000 	lds	w, LCD_IR	; read IR to check busy flag  (bit7)
000074   +  	JB1	w,7,LCD_wr_dr	; Jump if Bit=1 (still busy)
000076 dff4      	rcall	lcd_4us		; delay to increment DRAM addr counter
000077 9320 c000 	sts	LCD_DR, a0	; store a0 in DR
000079 9508      	ret	
         	
00007a   +  LCD_clear:		JW	LCD_wr_ir, 0b00000001	; clear display
00007c   +  LCD_home:		JW	LCD_wr_ir, 0b00000010	; return home
00007e   +  LCD_cursor_left:	JW	LCD_wr_ir, 0b00010000	; move cursor to left
000080   +  LCD_cursor_right:	JW	LCD_wr_ir, 0b00010100	; move cursor to right
000082   +  LCD_display_left:	JW	LCD_wr_ir, 0b00011000	; shifts display to left
000084   +  LCD_display_right:	JW	LCD_wr_ir, 0b00011100	; shifts display to right
000086   +  LCD_blink_on:		JW	LCD_wr_ir, 0b00001101	; Display=1,Cursor=0,Blink=1
000088   +  LCD_blink_off:		JW	LCD_wr_ir, 0b00001100	; Display=1,Cursor=0,Blink=0
00008a   +  LCD_cursor_on:		JW	LCD_wr_ir, 0b00001110	; Display=1,Cursor=1,Blink=0
00008c   +  LCD_cursor_off:		JW	LCD_wr_ir, 0b00001100	; Display=1,Cursor=0,Blink=0
         		
          LCD_init:
00008e b705      	in	w,MCUCR		; enable access to ext. SRAM
00008f 6c00      	sbr	w,(1<<SRE)+(1<<SRW)
000090 bf05      	out	MCUCR,w
000091   +  	CW	LCD_wr_ir, 0b00000001	; clear display
000093   +  	CW	LCD_wr_ir, 0b00000110	; entry mode set (Inc=1, Shift=0)
000095   +  	CW	LCD_wr_ir, 0b00001100	; Display=1,Cursor=0,Blink=0	
000097   +  	CW	LCD_wr_ir, 0b00111000	; 8bits=1, 2lines=1, 5x8dots=0
000099 9508      	ret
         
          LCD_pos:
         ; in	a0 = position (0x00..0x0f first line, 0x40..0x4f second line)
00009a 2f02      	mov	w,a0
00009b 6800      	ori	w,0b10000000
00009c cfc6      	rjmp	LCD_wr_ir
         
          LCD_cr:
         ; moving the cursor to the beginning of the line (carriage return)
00009d 9100 8000 	lds	w, LCD_IR	; read IR to check busy flag  (bit7)
00009f   +  	JB1	w,7,LCD_cr	; Jump if Bit=1 (still busy)
0000a1 7400      	andi	w,0b01000000	; keep bit6 (begin of line 1/2)
0000a2 6800      	ori	w,0b10000000	; write address command
0000a3 dfc7      	rcall	lcd_4us		; delay to increment DRAM addr counter
0000a4 9300 8000 	sts	LCD_IR,w	; store in IR
0000a6 9508      	ret
         
          LCD_lf:
         ; moving the cursor to the beginning of the line 2 (line feed)
0000a7 932f      	push	a0		; saveguard a0
0000a8 e420      	ldi	a0,$40		; load position $40 (begin of line 2)
0000a9 dff0      	rcall	LCD_pos		; set cursor position
0000aa 912f      	pop	a0		; restore a0
0000ab 9508      	ret          .include "printf.asm"		; include formatted printing routines
         ; file	printf.asm		formatted output
         ; copyright (c) 2000-2002 R.Holzer
         ; date	2001-06-25
         ; 2013.07.02 A.Schmid CA01
         
         ; === description ===
         ; 
         ; The program "printf" interprets and prints formatted strings.
         ; The special formatting characters regognized are:
         ;
         ; FDEC	decimal number
         ; FHEX	hexadecimal number
         ; FBIN	binary number
         ; FFRAC	fixed fraction number
         ; FCHAR	single ASCII character
         ; FSTR	zero-terminated ASCII string
         	
         ; The special formatting characters are distinguished from normal 
         ; ASCII characters by having bit7 set to 1.
         
         ; Signification of bit fields:
         ;
         ; b 	bytes		1..4 b bytes		2
         ; s 	sign		0(unsigned), 1(signed)	1
         ; i	integer digits	
         ; e 	base		2,,36			5
         ; dp 	dec. point	0..32			5
         ; $if		i=integer digits,  0=all digits,  1..15 digits 
         ;		f=fraction digits, 0=no fraction, 1..15 digits
         ;
         ; Formatting characters must be followed by an SRAM address (0..ff)
         ; FBIN,	sram
         ; FHEX,	sram
         ; FDEC,	sram
         ; FCHAR,sram
         ; FSTR,	sram
         ;
         ; The address sram is a 1-byte constante. It addresses
         ; 	 0..1f	registers r0..r31, 
         ; 	20..3f	i/o ports, (need to be addressed with an offset of $20)
         ;	60..ff	SRAM registers
         
         ; The FFRAC formatting character must be followed by 
         ;	ONE sram address and 
         ;	TWO more formatting characters
         ; FFRAC,sram,dp,$if
         
         ; dp	decimal point position, 0=right, 32=left
         ; $if	format i.f, i=integer digits, f=fraction digits
         
         ; The special formatting characters use the following coding
         ;
         ; FDEC	11bb'iiis	i=0 all digits, i=1-7 digits
         ; FBIN	101i'iiis	i=0 8 digits,	i=1-7 digits
         ; FHEX	1001'iiis	i=0 8 digits,	i=1-7 digits
         ; FFRAC	1000'1bbs
         ; FCHAR	1000'0100
         ; FSTR	1000'0101
         ; FREP	1000'0110
         ; FFUNC	1000'0111
         ;	1000'0010
         ;	1000'0011
         ; FESC	1000'0000
         
         ; examples
         ; formatting string		printing
         ; "a=",FDEC,a,0			1-byte variable a, unsigned decimal
         ; "a=",FDEC2,a,0			2-byte variable a (a1,a0), unsigend
         ; "a=",FDEC|FSIGN,a,0		1-byte variable 1, signed decimal
         ; "n=",FBIN,PIND+$20,0		i/o port, binary, notice offset of $20
         ; "f=",FFRAC4|FSIGN,a,16,$88,0	4-byte signed fixed-point fraction
         ;				dec.point at 16, 8 int.digits, 8 frac.digits	
         ; "f=",FFRAC2,a,16,$18,0		2-byte unsigned fixed-point fraction
         ;				dec.point at 16, 1 int.digits, 8 frac.digits	
         ; "a=",FDEC|FDIG5|FSIGN,a,0	1-byte variable, 5-digit, decimal, signed
         ; "a=",FDEC|FDIG5,a,0		1-byte variable, 5-digit, decimal, unsigned
         
         ; === registers modified ===
         ; e0,e1	used to transmit address of putc routine
         ; zh,zl	used as pointer to prog-memory
         
         ; === constants ==============================================
         
          .equ	FDEC	= 0b11000000	; 1-byte variable
          .equ	FDEC2	= 0b11010000	; 2-byte variable
          .equ	FDEC3	= 0b11100000	; 3-byte variable
          .equ	FDEC4	= 0b11110000	; 4-byte variable
         
          .equ	FBIN	= 0b10100000
          .equ	FHEX	= 0b10010100	; 1-byte variable
          .equ	FHEX2	= 0b10011000	; 2-byte variable
          .equ	FHEX3	= 0b10011100	; 3-byte variable
          .equ	FHEX4	= 0b10010000	; 4-byte variable
         
          .equ	FFRAC	= 0b10001000	; 1-byte variable
          .equ	FFRAC2	= 0b10001010	; 2-byte variable
          .equ	FFRAC3	= 0b10001100	; 3-byte variable
          .equ	FFRAC4	= 0b10001110	; 4-byte variable
         
          .equ	FCHAR	= 0b10000100
          .equ	FSTR	= 0b10000101
         
          .equ	FSIGN	= 0b00000001
         
          .equ	FDIG1	= 1<<1
          .equ	FDIG2	= 2<<1
          .equ	FDIG3	= 3<<1	
          .equ	FDIG4	= 4<<1
          .equ	FDIG5	= 5<<1
          .equ	FDIG6	= 6<<1
          .equ	FDIG7	= 7<<1
         
         ; ===macro ====================================================
         
          .macro	PRINTF			; putc function (UART, LCD...)
          	ldi	w, low(@0)	; address of "putc" in e1:d0
          	mov	e0,w
          	ldi	w,high(@0)
          	mov	e1,w
          	rcall	_printf
          	.endmacro
         
         ; mod	y,z
         
         
         ; === routines ================================================
         
          _printf:
0000ac   +  	POPZ			; z points to begin of "string"
0000ae   +  	MUL2Z			; multiply Z by two, (word ptr -> byte ptr)
0000b0   +  	PUSHX
         		
          _printf_read:
0000b2 95c8      	lpm			; places prog_mem(Z) into r0 (=c)
0000b3 9631      	adiw	zl,1		; increment pointer Z
0000b4 2000      	tst	r0		; test for ZERO (=end of string)
0000b5 f021      	breq	_printf_end	; char=0 indicates end of ascii string
0000b6 f04a      	brmi	_printf_formatted ; bit7=1 indicates formatting character
0000b7 2d00      	mov	w,r0
0000b8 d013      	rcall	_putw		; display the character
0000b9 cff8      	rjmp	_printf_read	; read next character in the string
         	
          _printf_end:
0000ba 9631      	adiw	zl,1		; point to the next character
0000bb   +  	DIV2Z			; divide by 2 (byte ptr -> word ptr)
0000bd   +  	POPX
0000bf 9409      	ijmp			; return to instruction after "string"
         
          _printf_formatted:
         
         ; FDEC	11bb'iiis
         ; FBIN	101i'iiis
         ; FHEX	1001'iiis
         ; FFRAC	1000'1bbs
         ; FCHAR	1000'0100
         ; FSTR	1000'0101
         
0000c0 fa00      	bst	r0,0		; store sign in T
0000c1 2d00      	mov	w,r0		; store formatting character in w
         
0000c2 95c8      	lpm	
0000c3 2da0      	mov	xl,r0		; load x-pointer with SRAM address
0000c4 27bb      	clr	xh		; clear high-byte
0000c5 9631       	adiw	zl,1		; increment pointer Z
         
         ;	JB1	w,6,_putdec
         ;	JB1	w,5,_putbin
         ;	JB1	w,4,_puthex
         ;	JB1	w,3,_putfrac
0000c6   +  	JK	w,FCHAR,_putchar
0000c8   +  	JK	w,FSTR ,_putstr
0000ca c015      	rjmp	_putnum
         	
0000cb cfe6      	rjmp	_printf_read	
         
         ; === putc (put character) ===============================
         ; in	w	character to put
         ;	e1,e0	address of output routine (UART, LCD putc)
          _putw:
0000cc   +  	PUSH3	a0,zh,zl
0000cf   +  	MOV3	a0,zh,zl, w,e1,e0
0000d2 9509      	icall			; indirect call to "putc"
0000d3   +  	POP3	a0,zh,zl
0000d6 9508      	ret
         
         ; === putchar (put character) ============================
         ; in	x	pointer to character to put
          _putchar:
0000d7 910c      	ld	w,x
0000d8 dff3      	rcall	_putw
0000d9 cfd8      	rjmp	_printf_read
         	
         ; === putstr (put string) ================================
         ; in	x	pointer to ascii string
         ;	b3,b2	address of output routine (UART, LCD putc)
          _putstr:
0000da 910d      	ld	w,x+
0000db 2300      	tst	w
0000dc f409      	brne	PC+2
0000dd cfd4      	rjmp	_printf_read
0000de dfed      	rcall	_putw
0000df cffa      	rjmp	_putstr
         
         ; === putnum (dec/bin/hex/frac) ===========================
         ; in	x	pointer to SRAM variable to print
         ; 	r0	formatting character
         	
          _putnum:
0000e0   +  	PUSH4	a3,a2,a1,a0	; saveguard a
0000e4   +  	PUSH4	b3,b2,b1,b0	; saveguard b	
0000e8   +  	LDX4	a3,a2,a1,a0	; load operand to print into a
         
         ; FDEC	11bb'iiis
         ; FBIN	101i'iiis
         ; FHEX	1001'iiis
         ; FRACT	1000'1bbs
         
0000ec   +  	JB1	w,6,_putdec
0000ee   +  	JB1	w,5,_putbin
0000f0   +  	JB1	w,4,_puthex
0000f2   +  	JB1	w,3,_putfrac
         
         ; FDEC	11bb'iiis
          _putdec:
0000f4 e06a      	ldi	b0,10		; b0 = base (10)
         
0000f5 2f70      	mov	b1,w
0000f6 9576      	lsr	b1
0000f7 7077      	andi	b1,0b111	
0000f8 9572      	swap	b1		; b1 = format 0iii'0000 (integer digits)
0000f9 e080      	ldi	b2,0		; b2 = dec. point position = 0 (right)
         	
0000fa 2f90      	mov	b3,w
0000fb 9592      	swap	b3
0000fc 7093      	andi	b3,0b11
0000fd 9593      	inc	b3		; b3 = number of bytes (1..4)
0000fe c01a      	rjmp	_getnum		; get number of digits (iii)
         
         ; FBIN	101i'iiis	addr
          _putbin:	
0000ff e062      	ldi	b0,2		; b0 = base (2)
000100 e094      	ldi	b3,4		; b3 = number of bytes (4)	
000101 c003      	rjmp	_getdig		; get number of digits (iii)
         
         ; FHEX	1001'iiis	addr
          _puthex:	
000102 e160      	ldi	b0,16		; b0 = base (16)
000103 e094      	ldi	b3,4		; b3 = number of bytes (4)
000104 c000      	rjmp	_getdig
         
          _getdig:
000105 2f70      	mov	b1,w
000106 9576      	lsr	b1
000107 7077      	andi	b1,0b111
000108 f409      	brne	PC+2
000109 e078      	ldi	b1,8		; if b1=0 then 8-digits
00010a 9572      	swap	b1		; b1 = format 0iii'0000 (integer digits)
00010b e080      	ldi	b2, 0		; b2 = dec. point position = 0 (right)
00010c c00c      	rjmp	_getnum
         
         ; FFRAC	1000'1bbs	addr	 00dd'dddd, 	iiii'ffff
         	
          _putfrac:
00010d e06a      	ldi	b0,10		; base=10	
00010e 95c8      	lpm
00010f 2d80      	mov	b2,r0		; load dec.point position
000110 9631      	adiw	zl,1		; increment char pointer
000111 95c8      	lpm
000112 2d70      	mov	b1,r0		; load ii.ff format
000113 9631      	adiw	zl,1		; increment char pointer
         	
000114 2f90      	mov	b3,w
000115 9595      	asr	b3
000116 7093      	andi	b3,0b11
000117 9593      	inc	b3		; b3 = number of bytes (1..4)
         
000118 c000      	rjmp	_getnum
         
          _getnum:
         ; in 	a	4-byte variable
         ; 	b3	number of bytes (1..4)
         ;	T	sign, 0=unsigned, 1=signed
         
000119   +  	JK	b3,4,_printf_4b
00011b   +  	JK	b3,3,_printf_3b
00011d   +  	JK	b3,2,_printf_2b	
         	
          _printf_1b:			; sign extension
00011f 2733      	clr	a1
000120 f416      	brtc	PC+3		; T=1 sign extension
000121 fd27      	sbrc	a0,7
000122 ef3f      	ldi	a1,0xff
          _printf_2b:
000123 2744      	clr	a2
000124 f416      	brtc	PC+3		; T=1 sign extension	
000125 fd37      	sbrc	a1,7
000126 ef4f      	ldi	a2,0xff
          _printf_3b:	
000127 2755      	clr	a3
000128 f416      	brtc	PC+3		; T=1 sign extension
000129 fd47      	sbrc	a2,7
00012a ef5f      	ldi	a3,0xff
          _printf_4b:
         
00012b d009      	rcall	_ftoa		; float to ascii
00012c   +  	POP4	b3,b2,b1,b0	; restore b
000130   +  	POP4	a3,a2,a1,a0	; restore a
         	
000134 cf7d      	rjmp	_printf_read
         
         ; ===============================================
         ; func	ftoa
         ; 
         ; converts a fixed-point fractional number to an ascii string
         ;
         ; by	Raphael Holzer
         ; date	16-6-2001
         ;
         ; in	a3-a0	variable to print
         ;	b0	base, 2 to 36, but usually decimal (10)
         ;	b1	number of digits to print ii.ff
         ; 	b2	position of the decimal point (0=right, 32=left)
         ;	T	sign (T=0 unsiged, T=1 signed)
         
          _ftoa:
000135 92cf      	push	d0
000136   +  	PUSH4	c3,c2,c1,c0	; c = fraction part, a = integer part
00013a   +  	CLR4	c3,c2,c1,c0	; clear fraction part
         
00013e f486      	brtc	_ftoa_plus	; if T=0 then unsigned
00013f 94e8      	clt
000140 2355      	tst	a3		; if MSb(a)=1 then a=-a
000141 f46a      	brpl	_ftoa_plus
000142 9468      	set			; T=1 (minus)
000143 2377      	tst	b1
000144 f009      	breq	PC+2		; if b1=0 the print ALL digits
000145 5170      	subi	b1,0x10		; decrease int digits
000146   +  	NEG4	a3,a2,a1,a0	; negate a
          _ftoa_plus:	
00014f 2388      	tst	b2		; b0=0 (only integer part)
000150 f051      	breq	_ftoa_int	
          _ftoa_shift:	
000151   +  	ASR4	a3,a2,a1,a0	; a = integer part	
000155   +  	ROR4	c3,c2,c1,c0	; c = fraction part
000159   +  	DJNZ	b2,_ftoa_shift
          _ftoa_int:
00015b 937f      	push	b1		; ii.ff (ii=int digits)
00015c 9572      	swap	b1
00015d 707f      	andi	b1,0x0f
         	
00015e e20e      	ldi	w,'.'		; push decimal point
00015f 930f      	push	w
          _ftoa_int1:
000160 d045      	rcall	_div41		; int=int/10
000161 2d0c      	mov	w,d0		; d=reminder
000162 d030      	rcall	_hex2asc
000163 930f      	push	w		; push rem(int/10)
000164   +  	TST4	a3,a2,a1,a0	; (int/10)=?
000169 f029      	breq	_ftoa_space	; (int/10)=0 then finished
00016a 2377      	tst	b1
00016b f3a1      	breq	_ftoa_int1	; if b1=0 then print ALL int-digits
00016c   +  	DJNZ	b1,_ftoa_int1
00016e c007      	rjmp	_ftoa_sign
          _ftoa_space:
00016f 2377      	tst	b1		; if b1=0 then print ALL int-digits
000170 f029      	breq	_ftoa_sign
000171 957a      	dec	b1
000172 f019      	breq	_ftoa_sign
000173 e200      	ldi	w,' '		; write spaces
000174 df57      	rcall	_putw	
000175 cff9      	rjmp	_ftoa_space
          _ftoa_sign:
000176 f416      	brtc	PC+3		; if T=1 then write 'minus'
000177 e20d      	ldi	w,'-'
000178 df53      	rcall	_putw
          _ftoa_int3:
000179 910f      	pop	w
00017a 320e      	cpi	w,'.'
00017b f011      	breq	PC+3
00017c df4f      	rcall	_putw
00017d cffb      	rjmp	_ftoa_int3
         
00017e 917f      	pop	b1		; ii.ff (ff=frac digits)
00017f 707f      	andi	b1,0x0f
000180 2377      	tst	b1
000181 f059      	breq	_ftoa_end
          _ftoa_point:	
000182 df49      	rcall	_putw		; write decimal point
000183   +  	MOV4	a3,a2,a1,a0, c3,c2,c1,c0		
          _ftoa_frac:
000187 d011      	rcall	_mul41		; d.frac=10*frac
000188 2d0c      	mov	w,d0
000189 d009      	rcall	_hex2asc
00018a df41      	rcall	_putw
00018b   +  	DJNZ	b1,_ftoa_frac
          _ftoa_end:
00018d   +  	POP4	c3,c2,c1,c0
000191 90cf      	pop	d0
000192 9508      	ret
         
         ; === hexadecimal to ascii ===
         ; in	w
          _hex2asc:
000193 300a      	cpi	w,10
000194 f410      	brsh	PC+3
000195   +  	addi	w,'0'
000196 9508      	ret
000197   +  	addi	w,('a'-10)
000198 9508      	ret
         
         ; === multiply 4byte*1byte ===
         ;
         ; by	Raphael Holzer, EPFL
         ; date	16-6-2001
         ; 
         ; multiplies a3-a0 (4-byte) by b0 (1-byte)
         ;
         ; in	a3..a0	multiplicand (argument to multiply)
         ;	b0	multiplier
         ; out	a3..a0	result
         ; 	d0	result MSB (byte 4)
         ;
000199 24cc      _mul41:	clr	d0		; clear byte4 of result
00019a e200      	ldi	w,32		; load bit counter
00019b 9488      __m41:	clc			; clear carry
00019c fd20      	sbrc	a0,0		; skip addition if LSB=0
00019d 0ec6      	add	d0,b0		; add b to MSB of a
00019e   +  	ROR5	d0,a3,a2,a1,a0	; shift-right c, LSB (of b) into carry
0001a3   +  	DJNZ	w,__m41		; Decrement and Jump if bit-count Not Zero
0001a5 9508      	ret
         
         ; === divide 4byte/1byte ===
         ;
         ; in	a0..a3 	divident (argument to divide)
         ;	b0 	divider
         ; out	a0..a3 	result 
         ;	d0	reminder
         ;
0001a6 24cc      _div41:	clr	d0		; d will contain the remainder
0001a7 e200      	ldi	w,32		; load bit counter
0001a8   +  __d41:	ROL5	d0,a3,a2,a1,a0	; shift carry into result c
0001ad 1ac6      	sub	d0, b0		; subtract b from remainder
0001ae f408      	brcc	PC+2	
0001af 0ec6      	add	d0, b0		; restore if remainder became negative
0001b0   +  	DJNZ	w,__d41		; Decrement and Jump if bit-count Not Zero
0001b2   +  	ROL4	a3,a2,a1,a0	; last shift (carry into result c)
0001b6   +  	COM4	a3,a2,a1,a0	; complement result
0001ba 9508      	ret
          .include "alphabet.asm"
         ; file: alphabet.asm 
         ; Goal : define const chars for alphabet in order to print
          _a:
          .db	"A",0
0001bb 0041
         
          _b:
          .db	"B",0
0001bc 0042
         
          _c:
          .db	"C",0
0001bd 0043
         
          _d:
          .db	"D",0
0001be 0044
         
          _e:
          .db	"E",0
0001bf 0045
         
          _f:
          .db	"F",0
0001c0 0046
         
          _g:
          .db	"G",0
0001c1 0047
         
          _h:
          .db	"H",0
0001c2 0048
         
          _i:
          .db	"I",0
0001c3 0049
         
          _j:
          .db	"J",0
0001c4 004a
         
          _k:
          .db	"K",0
0001c5 004b
         
          _l:
          .db	"L",0
0001c6 004c
         
          _m:
          .db	"M",0
0001c7 004d
         
          _n:
          .db	"N",0
0001c8 004e
         
          _o:
          .db	"O",0
0001c9 004f
         
          _p:
          .db	"P",0
0001ca 0050
         
          _q:
          .db	"Q",0
0001cb 0051
         
          _r:
          .db	"R",0
0001cc 0052
         
          _s:
          .db	"S",0
0001cd 0053
         
          _t:
          .db	"T",0
0001ce 0054
         
          _u:
          .db	"U",0
0001cf 0055
         
          _v:
          .db	"V",0
0001d0 0056
         
          _w:
          .db	"W",0
0001d1 0057
         
          _x:
          .db	"X",0
0001d2 0058
         
          _y:
          .db	"Y",0
0001d3 0059
         
          _z:
          .db	"z",0
0001d4 007a
         		
         		
         ;============= Main Program ==========================
          main:
0001d5 9a36      	sbi	ADCSR,ADSC	; AD start conversion
0001d6   +  	WP1	ADCSR,ADSC	; wait if ADIF=0 
0001d8 b0c4      	in	d0,ADCL		; read low byte first
0001d9 b0d5      	in	d1,ADCH		; read high byte  second
0001da   +  	LSR_2	d0
0001dc 2d6c      	mov 	b0,d0		; round up to use 1 byte
0001dd   +  	LSL_6	d1
0001e3 0d6d      	add	b0,d1
0001e4 576f      	subi	b0,SIGNED	; force b0 to signed int for subtraction
0001e5 e37f      	ldi	b1,LEVEL_SND	; valeur de seuil
0001e6 1b67      	sub	b0,b1		; soustraction seuil
0001e7 f00a      	brmi	PC+2		; PC+2 si inferieur seuil
0001e8 d002      	rcall	sound		; if > seuil, sound
0001e9 d00c      	rcall	nosound		; if < seuil, no sound
0001ea cfea      	rjmp	main
         
         ;============= Sound processing ==========================
         ; Called if sound is detected	
          sound:	
0001eb 2d0a      	mov	w,c2
0001ec e021      	ldi	a0,1
0001ed 20bb      	tst	c3		; tst if timer has been started on this pic
0001ee f411      	brne	PC+3		; if not, jump to
0001ef 94b3      	inc	c3		; if so, set to 1
0001f0 de71      	rcall	clr_timer	; and reset timer
0001f1 1b02      	sub	w,a0		; tst if counter has been inc on this pic 
0001f2 f011      	breq	PC+3		; if it has jump to
0001f3 94a3      	inc	c2		; if it hasn't set to 1
0001f4 9483      	inc	c0		; and inc pic counter
0001f5 9508      	ret
         
         ; Called if sound is not detected
          nosound:
0001f6 24aa      	clr	c2		; clear counters
0001f7 9508      	ret
         
         ; Determine is sound is short or long	
          shortlong:
0001f8 baf8      	out	PORTB,d3
0001f9 e003      	ldi	w,3		; check for 3 empty in a row
0001fa 1909      	sub	w,c1		
0001fb f411      	brne	PC+3
0001fc d01b      	rcall	sendbuffer	; if so, send buffer
0001fd 9508      	ret			; and return
0001fe 20ee      	tst	d2		; test if pulse counter is empty
0001ff f411      	brne	PC+3		; to avoid unnecessary computation
000200 24bb      	clr	c3
000201 9508      	ret
000202 e001      	ldi	w,0b1		; load 1 into temp reg
000203 190e      	sub	w,d2		; 1-counter=?
000204 f411      	brne	PC+3		; if counter!=1, branch to test ?=3
000205 d006      	rcall	buffershort	; and buffer short signal
000206 9508      	ret			; then return
000207 e003      	ldi	w,0b11		; load 3 into tmp
000208 190e      	sub	w,d2		; 3-counter=?
000209 f409      	brne	PC+2		; if counter !=3, ret
00020a d007      	rcall	bufferlong	; buffer long signal
00020b 9508      	ret
         
         ;============= Buffering ==========================
         ; Buffer a short symbol
          buffershort:
00020c e001      	ldi	w,SHORT_SYMB	; load 01 for short pulse
00020d   +  	LSL_2	d3		; buffer << 2
00020f 0ef0      	add	d3,w		; insert 01 to LSBs
000210 9593      	inc	b3 
000211 9508      	ret
         
         ; Buffer a long symbol
          bufferlong:
000212 e002      	ldi	w,LONG_SYMB	; load 10 for short pulse
000213   +  	LSL_2	d3		; buffer << 2
000215 0ef0      	add	d3,w		; insert 10 to LSBs
000216 9593      	inc	b3
000217 9508      	ret
         
         ; Send buffer to be decoded	
          sendbuffer:
000218 20ff      	tst	d3		; check for no signal
000219 f409      	brne	PC+2		; if empty, return
00021a 9508      	ret
00021b 20ff      	tst	d3		; check for empty buffer
00021c f019      	breq	PC+4		; if empty jump decode step
00021d d003      	rcall	alphabet	; decode with alphabet
00021e 24ff      	clr	d3		; clear d3 after decoding
00021f 2799      	clr	b3		; clear char counter after decoding
000220 9508      	ret
         	
         ; Alphabet decoder routine
          alphabet:
000221 2d4f      	mov     r20,d3		; place buffer in temp register
000222 7041      	andi	r20,0x01	; Test if letter finish with a Dash
000223 f411      	brne    PC+3		; if so, ignore this line
000224 c003      	rjmp	alphabet_dash
000225 9508      	ret
000226 c03a      	rjmp	alphabet_dot	; if not, jump here		   
000227 9508      	ret
         ; Alphabet decoder subroutine (part of alphabet starting with dash)
          alphabet_dash:
         	; " x x x - "
000228 2d4f         	mov     r20,d3		
000229 704c         	andi	r20,0x0c        ; Test if letter has only one character
00022a f411          	brne    PC+3		
00022b d0df          	rcall	print_t
00022c 9508          	ret
         
00022d 2d4f         	mov     r20,d3		
00022e 7044          	andi    r20,0x04	; Test if letter has a Dot as 2nd character
00022f f4b1          	brne    PC+23		; if so, jump far far away
         
                 ; " x x - - "
000230 2d4f              mov     r20,d3
000231 7340              andi    r20,0x30
000232 f411              brne    PC+3
000233 d0b4              rcall	print_m
000234 9508              ret
                 
000235 2d4f              mov	r20,d3
000236 7140              andi	r20,0x10
000237 f439              brne	PC+8
                 
                 ; " x - - - "
                 
000238 2d4f              mov     r20,d3
000239 7c40              andi    r20,0xc0
00023a f411              brne    PC+3
00023b d0b6              rcall	print_o
00023c 9508              ret
                 
00023d d09b              rcall	print_j
00023e 9508              ret
                 
                 ; " x ° - - "
                 
00023f 2d4f              mov     r20,d3
000240 7c40              andi    r20,0xc0
000241 f411              brne	PC+3
000242 d0d7              rcall	print_w
000243 9508              ret
                 
000244 d0df              rcall	print_y
000245 9508              ret
                 
                 ; " x x ° - "
                 
000246 2d4f              mov     r20,d3
000247 7340              andi    r20,0x30
000248 f411              brne    PC+3
000249 d062              rcall	print_a
00024a 9508              ret
                 
00024b 2d4f              mov     r20,d3
00024c 7140              andi    r20,0x10
00024d f451              brne    PC+11
                
                	
         	; " x - ° - "
         	
00024e 2d4f      	mov     r20,d3
00024f 7c40              andi    r20,0xc0
000250 f411              brne	PC+3
000251 d08c              rcall	print_k
000252 9508              ret
                 
000253 d0a8              rcall	print_q
000254 9508              ret
                 
                 ; " x ° ° - "
                 
000255 2d4f              mov	r20,d3
000256 7c40              andi	r20,0xc0
000257 f411              brne	PC+3
000258 d0b7              rcall	print_u
000259 9508              ret
                 
00025a 2d4f              mov	r20,d3
00025b 7440              andi	r20,0x40
00025c f411              brne	PC+3
                 
00025d d0c1              rcall	print_x
00025e 9508              ret
                 
00025f d0b5              rcall	print_v
000260 9508              ret
         
         ; Alphabet decoder subroutine (part of alphabet starting with dot)
          alphabet_dot:
         
         	;" x x x ° "
         	
000261 2d4f      	mov     r20,d3		
000262 704c         	andi	r20,0x0c        ; Test if letter has only one character
000263 f411          	brne    PC+3		
000264 d05b          	rcall	print_e
000265 9508          	ret
         
000266 2d4f         	mov     r20,d3		
000267 7044          	andi    r20,0x04	; Test if letter has a Dot as 2nd character
000268 f4d9          	brne    PC+28		; if so, jump far far away
         
                 ; " x x - ° "
000269 2d4f              mov     r20,d3
00026a 7340              andi    r20,0x30
00026b f411              brne    PC+3
00026c d080              rcall	print_n
00026d 9508              ret
                 
00026e 2d4f              mov	r20,d3
00026f 7140              andi	r20,0x10
000270 f439              brne	PC+8
                 
                 ; " x - - ° "
                 
000271 2d4f              mov     r20,d3
000272 7c40              andi    r20,0xc0
000273 f411              brne    PC+3
000274 d055              rcall	print_g
000275 9508              ret
                 
000276 d080              rcall	print_p
000277 9508              ret
                 
                 ; " x ° - ° "
                 
000278 2d4f              mov     r20,d3
000279 7c40              andi    r20,0xc0
00027a f411              brne    PC+3
00027b d085              rcall	print_r
00027c 9508              ret
                 
00027d 2d4f              mov	r20,d3
00027e 7440             	andi	r20,0x40
00027f f411             	brne	PC+3
000280 d035             	rcall	print_c
000281 9508             	ret
                	
000282 d042              rcall	print_f
000283 9508              ret
                 
                 ; " x x ° ° "
                 
000284 2d4f              mov     r20,d3
000285 7340              andi    r20,0x30
000286 f411              brne    PC+3
000287 d04c              rcall	print_i
000288 9508              ret
                 
000289 2d4f              mov     r20,d3
00028a 7140              andi    r20,0x10
00028b f451              brne    PC+11
                
                	
         	; " x - ° ° "
         	
00028c 2d4f      	mov     r20,d3
00028d 7c40              andi    r20,0xc0
00028e f411              brne    PC+3
00028f d02b              rcall	print_d
000290 9508              ret
                 
000291 2d4f              mov	r20,d3
000292 7440              andi	r20,0x40
000293 f411              brne	PC+3
                 
000294 d094              rcall	print_z
000295 9508              ret
                 
000296 d04c              rcall	print_l
000297 9508              ret
                 
                 ; " x ° ° ° "
                 
000298 2d4f              mov	r20,d3
000299 7c40              andi	r20,0xc0
00029a f411              brne	PC+3
00029b d06a              rcall	print_s
00029c 9508              ret
                 
00029d 2d4f              mov	r20,d3
00029e 7440              andi	r20,0x40
00029f f411              brne	PC+3
                 
0002a0 d010              rcall	print_b
0002a1 9508              ret
                 
0002a2 d02c              rcall	print_h
0002a3 9508              ret	
         
         ;============= Printing characters to LCD ==========================
         ; print char to LCD
          .macro	PRINT_CHAR
          	ldi	r16,short
          	ldi	zl,low(2*@0)
          	ldi	zh,high(2*@0)
          	rcall	LCD_putstring
          .endmacro
         
         ; print string to LCD	
          LCD_putstring:
0002a4 95c8      	lpm
0002a5 2000      	tst	r0
0002a6 f021      	breq	done
0002a7 2d20      	mov	a0,r0
0002a8 ddc5      	rcall	LCD_putc
0002a9 9631      	adiw	zl,1
0002aa cff9      	rjmp	LCD_putstring
         
0002ab 9508      done:ret
         
         
          print_a:
0002ac   +  	PRINT_CHAR	_a
0002b0 9508      	ret
         	
          print_b:
0002b1   +  	PRINT_CHAR	_b
0002b5 9508      	ret
         	
          print_c:
0002b6   +  	PRINT_CHAR	_c
0002ba 9508      	ret
         	
          print_d:
0002bb   +  	PRINT_CHAR	_d
0002bf 9508      	ret
         	
          print_e:
0002c0   +  	PRINT_CHAR	_e
0002c4 9508      	ret
         	
          print_f:
0002c5   +  	PRINT_CHAR	_f
0002c9 9508      	ret
         	
          print_g:
0002ca   +  	PRINT_CHAR	_g
0002ce 9508      	ret
         	
          print_h:
0002cf   +  	PRINT_CHAR	_h
0002d3 9508      	ret
         	
          print_i:
0002d4   +  	PRINT_CHAR	_i
0002d8 9508      	ret
         	
          print_j:
0002d9   +  	PRINT_CHAR	_j
0002dd 9508      	ret
         	
          print_k:
0002de   +  	PRINT_CHAR	_k
0002e2 9508      	ret
         	
          print_l:
0002e3   +  	PRINT_CHAR	_l
0002e7 9508      	ret
         	
          print_m:
0002e8   +  	PRINT_CHAR	_m
0002ec 9508      	ret
         	
          print_n:
0002ed   +  	PRINT_CHAR	_n
0002f1 9508      	ret
         	
          print_o:
0002f2   +  	PRINT_CHAR	_o
0002f6 9508      	ret
         	
          print_p:
0002f7   +  	PRINT_CHAR	_p
0002fb 9508      	ret
         	
          print_q:
0002fc   +  	PRINT_CHAR	_q
000300 9508      	ret
         	
          print_r:
000301   +  	PRINT_CHAR	_r
000305 9508      	ret
         	
          print_s:
000306   +  	PRINT_CHAR	_s
00030a 9508      	ret
         	
          print_t:
00030b   +  	PRINT_CHAR	_t
00030f 9508      	ret
         	
          print_u:
000310   +  	PRINT_CHAR	_u
000314 9508      	ret
         	
          print_v:
000315   +  	PRINT_CHAR	_v
000319 9508      	ret
         	
          print_w:
00031a   +  	PRINT_CHAR	_w
00031e 9508      	ret
         	
          print_x:
00031f   +  	PRINT_CHAR	_x
000323 9508      	ret
         	
          print_y:
000324   +  	PRINT_CHAR	_y
000328 9508      	ret
         	
          print_z:
000329   +  	PRINT_CHAR	_z
00032d 9508      	ret
         	
         		
Assembly complete with no errors.
