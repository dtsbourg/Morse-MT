; file	ad.asm
.include "m103def.inc"		; include AVR port/bit definitions
.include "macros.asm"		; include macro definitions
.include "definitions.asm"	; include register/constant definitions

.equ 	MORSE_PORT = 2

;============== Interrupt Vector Table ===============
.org	0 
	rjmp	reset  
.org	OVF0addr
	rjmp	analyse
.org	0x30

short:
.db	"short",0

long:
.db	"long ",0

;============== Interrupt Service Routine ============	

analyse:
	ldi	_w,0x1e	; _w=30 (nb de pics)
	mov	_u,c0	; place pic counter in tmp reg _u
	sub	_u,_w	; _u-_w=?
	brlo	PC+4	; if nb de pics > seuil, inc counter
	inc	d2	
	clr	c0	; clear pic counter
	reti		; return for interrupt
	rcall	shortlong ; if no sound, check previous counter
	clr	d2	; clear after compare
	reti
	
;============== Initialisation Reset =================
reset:
	LDSP	RAMEND		; set up stack pointer (SP)
	
	OUTI	PORTB,0xff
	;OUTI	DDRD,0x00
	OUTI	DDRB,0xff
	
	OUTI	ADCSR,(1<<ADEN)+1; AD Enable, PS=CK/2	
	OUTI	ADMUX,MORSE_PORT; select channel MORSE_PORT
	
	OUTI	TIMSK,(1<<TOIE0)
	OUTI	ASSR,(1<<AS0)
	OUTI 	TCCR0,3
	sei
	
	rcall	clr_init
	rcall	LCD_init	; initialize the LCD
	
	rjmp	main		; jump ahead to the main program

;============= Init routines ========================
; init counter : clear ALL the counters !	
clr_init:
	clr	c0		; compteur de pics 
	clr	d0		
	clr	d1
	clr	d2
	clr	d3
	clr	a3
	ret	
	

.include "lcd.asm"		; include the LCD routines
.include "printf.asm"		; include formatted printing routines
		
		
;============= Main Program ==========================
main:
	sbi	ADCSR,ADSC	; AD start conversion
	WP1	ADCSR,ADSC	; wait if ADIF=0 
	in	d0,ADCL		; read low byte first
	in	d1,ADCH		; read high byte  second
	LSR_2	d0
	mov 	b0,d0		; round up to use 1 byte
	LSL_6	d1
	add	b0,d1
	subi	b0,127
	ldi	b1,63		; valeur de seuil
	sub	b0,b1		; soustraction seuil
	brmi	PC+2		; PC+2 si inferieur seuil
	rcall	print
	bclr	1
	rcall	printno
	rjmp	main

;============= Display routines ========================
; print string "long" to LCD
printlong:
	rcall	LCD_clear
	ldi	r16,long
	ldi	zl,low(2*long)
	ldi	zh,high(2*long)
	rcall	LCD_putstring
	ret

; print string "short" to LCD
printcourt:
	rcall	LCD_clear
	ldi	r16,short
	ldi	zl,low(2*short)
	ldi	zh,high(2*short)
	rcall	LCD_putstring
	ret

; print string to LCD	
LCD_putstring:
	lpm
	tst	r0
	breq	done
	mov	a0,r0
	rcall	LCD_putc
	adiw	zl,1
	rjmp	LCD_putstring

done:ret

; print to screen nil if no sound	
printno:
	nop
	ret

; print to screen if sound	
print:
	tst	a3		; reset timer when first sound detected
	brne	PC+2		; allows sync between timer and sound
	rcall	printa
	inc	a3
	OUTI	TCNT0,0		; reset TCNT0 register (timer counter)
	brts	PC+2
	rcall	printa
	ret

printa:
	bset	1		; sinon, set T
	inc	c0		; inc compteur de pics 
	ret
	
; determine if sound is long or short	
shortlong:
	rcall	LCD_clear	; clear LCD
	ldi	w,0b11		; load 0b11 into temp reg
	;out	PORTB,d2	; print to LED value of counter
	sub	w,d2		; 0b11-counter=?
	brne	PC+3		; if counter!=0b11, branch to test =3
	;rcall	printcourt	; if counter = 0b11, print short
	rcall	buffercourt	; and buffer short signal
	ret			; then return
	ldi	w,0b111		; load 0b111 into tmp
	sub	w,d2		; 3-counter=?
	brne	PC+2		; if counter !=3, ret
	;rcall	printlong	; else print long
	rcall	bufferlong	; buffer long signal
	rcall	buffernil	; buffer nil signal
	ret

;============= Buffer routines ========================
; add a long to buffer	
bufferlong:
	clr	c1		; clear blank counter
	ldi	w,0b10		; symbol for long 0b10
	LSL_2	d3		; d3 << 2
	add	d3,w		; add to buffer
	ret

; add a short to buffer				
buffercourt:
	clr	c1		; clear blank counter
	ldi	w,0b01		; symbol for short 0b01
	LSL_2	d3
	add	d3,w
	ret

; add a nil to buffer
buffernil:
	mov	w,c1		; w is placeholder
	subi	w,2		; check if there have been 3 empty in a row
	breq	PC+3		; if so, jump to send buffer (ie there was a letter)
	inc	c1		; if not, increment empty counter
	ret	
	clr	c1		; clear empty counter
	rcall	sendbuffer	; send buffer to alphabet decoder
	ret

; send buffer to alphabet decoder
sendbuffer:
	;mov	a3,d3		; Try convert buffer to format 0bxx xx xx xx (with
	;andi	a3,0b11000000	; empty values at LSBs)
	;tst	a3
	;brne	PC+4
	;LSL_2	d3
	;rjmp	sendbuffer
	out	PORTB,d3	; print buffer values to LEDs
	mov	a2,d3		; place buffer in tmp reg
	tst	d3
	breq	PC+2
	;rcall	alphabet	; call alphabet decoder (uses a2)
	clr	d3		; clear buffer
	ret


;========== Recherche lettre associée ========

; alphabet decoder routine
alphabet:
	mov     r20,a2         ; place buffer in temp register
	andi	r20,0x40       ; Test if letter begin wth a Dash
	brne    PC+3           ; if so, ignore this line
	rjmp	alphabet_dash
	ret
	rjmp	alphabet_dot   ; if not, jump here
	ret

alphabet_dash:
	; " - "
   	mov     r20,a2		
   	andi	r20,0x30        ; Test if letter has only one character
    	brne    PC+4		
    	PRINTF  LCD
.db "T",0
    	ret

   	mov     r20,a2		
    	andi    r20,0x10	; Test if letter has a Dot as 2nd character
    	brne    PC+28		; if so, jump far far away

        ; " - - "
        mov     r20,a2
        andi     r20,0x0c
        brne    PC+4
        PRINTF  LCD
.db "M",0
        ret

        mov     r20,a2
        andi    r20,0x04
        brne    PC+4

       	; " - - - "
        PRINTF  LCD
.db "O",0
        ret

       	; " - - ° "

        mov     r20,a2
        andi    r20,0x03
       	brne    PC+4

       	PRINTF  LCD
.db "G",0
	ret

	mov     r20,a2
	andi    r20,0x01
	brne    PC+4

	PRINTF  LCD
.db "Q",0
	ret

	PRINTF  LCD
.db "Z",0
	ret

        ; " - ° "

	mov     r20,a2
	andi	r20,0x0c
	brne    PC+4
        
	PRINTF  LCD
.db "N",0
	ret

	mov     r20,a2
	andi    r20,0x04
	brne    PC+16

       	; " - ° - "


	mov     r20,a2
	andi    r20,0x03
	brne    PC+4

	PRINTF  LCD
	.db "K",0
	ret

	mov     r20,a2
	andi    r20,0x01
	brne    PC+4

	PRINTF  LCD
.db "Y",0
	ret

	PRINTF  LCD
.db "C",0
	ret

	; " - ° ° "

	mov     r20,a2
	andi    r20,0x03
	brne    PC+4

	PRINTF  LCD
.db "D",0
	ret

	mov     r20,a2
	andi    r20,0x01
	brne    PC+4

	PRINTF  LCD
.db "X",0
	ret

	PRINTF  LCD
.db "B",0
	ret





alphabet_dot:

	; " ° "
	mov     r20,a2
	andi    r20,0x30
	brne    PC+4

	PRINTF  LCD
.db "E",0
	ret

	mov     r20,a2
	andi    r20,0x10
	brne    PC+34

	; " ° - "
	mov     r20,a2
	andi    r20,0x0c
	brne    PC+4
        
	PRINTF  LCD
.db "A",0
	ret

	mov     r20,a2
	andi    r20,0x04
	brne    PC+4

	; " ° - - "

	mov     r20,a2
	andi    r20,0x03
	brne    PC+4

	PRINTF  LCD
.db "W",0
	ret

	mov     r20,a2
	andi    r20,0x01
	brne    PC+4

	PRINTF  LCD
.db "J",0
        ret

	PRINTF  LCD
.db "P",0
	ret


	; " ° - ° "

	mov     r20,a2
	andi    r20,0x03
	brne    PC+4

	PRINTF  LCD
.db "R",0
	ret

	PRINTF  LCD
.db "L",0
	ret

	; " ° ° "

	mov     r20,a2
	andi    r20,0x0c
	brne    PC+4
        
	PRINTF  LCD
.db "I",0
	ret

	mov     r20,a2
	andi    r20,0x04
	brne    PC+10

	; " ° ° - "


	mov     r20,a2
	andi    r20,0x03
	brne    PC+4

	PRINTF  LCD
.db "U",0
	ret


	PRINTF  LCD
.db "F",0
	ret

	; " ° ° ° "

	mov     r20,a2
	andi    r20,0x03
	brne    PC+4

	PRINTF  LCD
.db "S",0
	ret

	mov     r20,a2
	andi    r20,0x01
	brne    PC+4

        PRINTF  LCD
.db "V",0
        ret

	PRINTF  LCD
.db "H",0
	ret

